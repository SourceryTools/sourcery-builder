# Common support functions for self-tests.

# Copyright 2018-2021 Mentor Graphics Corporation.

# This program is free software; you can redistribute it and/or modify
# it under the terms of the GNU Lesser General Public License as
# published by the Free Software Foundation; either version 2.1 of the
# License, or (at your option) any later version.

# This program is distributed in the hope that it will be useful, but
# WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
# Lesser General Public License for more details.

# You should have received a copy of the GNU Lesser General Public
# License along with this program; if not, see
# <https://www.gnu.org/licenses/>.

"""Common support functions for self-tests."""

import contextlib
import os
import os.path

__all__ = ['create_files', 'read_files', 'redirect_file', 'parse_makefile']


def create_files(top, dirs, files, symlinks):
    """Create a structure of directories, files and symlinks."""
    os.mkdir(top)
    for subdir in dirs:
        os.mkdir(os.path.join(top, subdir))
    for filename in files:
        with open(os.path.join(top, filename), 'w', encoding='utf-8') as file:
            file.write(files[filename])
    for linkname in symlinks:
        os.symlink(symlinks[linkname], os.path.join(top, linkname))


def read_files(top):
    """Return details of directories, files and symlinks present."""
    dirs = set()
    files = {}
    symlinks = {}
    for subdir in os.scandir(top):
        if subdir.is_file(follow_symlinks=False):
            with open(subdir.path, 'r', encoding='utf-8') as file:
                files[subdir.name] = file.read()
        elif subdir.is_symlink():
            symlinks[subdir.name] = os.readlink(subdir.path)
        else:
            dirs.add(subdir.name)
            sub_dirs, sub_files, sub_symlinks = read_files(subdir.path)
            for dirname in sub_dirs:
                dirs.add(os.path.join(subdir.name, dirname))
            for filename in sub_files:
                files[os.path.join(subdir.name,
                                   filename)] = sub_files[filename]
            for linkname in sub_symlinks:
                symlinks[os.path.join(subdir.name,
                                      linkname)] = sub_symlinks[linkname]
    return dirs, files, symlinks


@contextlib.contextmanager
def _with_dup(old_fd):
    """Open a file descriptor with dup that is automatically closed."""
    new_fd = os.dup(old_fd)
    try:
        yield new_fd
    finally:
        os.close(new_fd)


@contextlib.contextmanager
def _with_open(*args, **kwargs):
    """Open a file descriptor with open that is automatically closed."""
    new_fd = os.open(*args, **kwargs)
    try:
        yield new_fd
    finally:
        os.close(new_fd)


@contextlib.contextmanager
def redirect_file(file, name):
    """Redirect output to a file for code in a 'with' statement."""
    file.flush()
    with _with_dup(file.fileno()) as old_out_fd:
        with _with_open(name,
                        os.O_WRONLY | os.O_CREAT | os.O_TRUNC) as new_out_fd:
            try:
                os.dup2(new_out_fd, file.fileno())
                yield
            finally:
                os.dup2(old_out_fd, file.fileno())


def parse_makefile(text):
    """Parse a makefile.

    This is limited to makefiles as generated by the Makefile class,
    and returns a dict mapping makefile target to dependencies, and
    one mapping makefile target to lists of commands.

    """
    deps = {}
    commands = {}
    current_target = None
    for line in text.split('\n'):
        if line == '':
            continue
        if line.startswith('\t@'):
            command = line[len('\t@'):]
            commands[current_target].append(command)
        else:
            current_target, rest = line.split(':', 1)
            rest = rest.strip()
            if current_target in deps:
                raise ValueError('duplicate target %s' % current_target)
            else:
                deps[current_target] = rest.split()
                commands[current_target] = []
    return deps, commands
